[{"title":"操作系统内存分配","url":"/2024/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","content":"连续分配方式单一连续分配（过时 整个内存只能有一个程序。\n 内存被分为 系统区和用户区，系统区用于装操作系统的相关数据，用户区用于装程序。由于整个用户区只能有一个程序，因此内存利用率极差。   \n固定分区分配固定分区能够支持多道程序。\n原理是：把用户区进一步分成多个分区，每一个分区存放一个进程。固定分区分配又分成两种：一种是各个分区大小相同，另一种是各个分区大小不相等。\n   \n\n分区大小不等有利于存放大小不同的进程。\n当操作系统用到分区技术时，都会维护一个数据结构—-分区说明表，来实现各个分区的分配与回收，每个表项对应一个分区，通常按分区大小排列，用数组或链表都可以表示这张表，表具体如下：\n   \n\n优点：实现简单，无外部碎片。(外部碎片即用户区里有未被用到的地方，由于分区是刚好占满用户去的，故没有外部碎片)\n缺点：存在内部碎片(即分区内因进程没占满分区而多出来未被使用的地方)；而且遇到一个大进程，以致所有分区都放不下，那就只能使用覆盖技术，覆盖技术由于会把进程的某些段从外存和内存之间调出调入，因此会增加I&#x2F;O开销。\n动态分区分配亮点：这种分区方式不会预先划分内存分区，而是在进程装入内存时，再动态地根据进程的大小建立分区。使得分区的大小刚好适合进程使用。\n存在的问题：（如下图）\n由于进程在运行完后，会退出内存，留下空余的碎片，如下面的6MB和10MB和4MB。此时若 有一个 20MB的进程进来，则虽然空闲空间刚刚好有20MB，但依然是放不下的。这就是存在的问题，为了解决这个问题，只能引入拼凑技术。\n拼凑技术：\n拼接技术&#x2F;紧凑技术：移动内存中所有已经分配区到内存的一端，将其余空闲分区合并为一个大的空闲分区\n非连续内存分配策略","tags":["操作系统"]}]